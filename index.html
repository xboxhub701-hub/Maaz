<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>X Timer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Fjalla+One&display=swap" rel="stylesheet">
    <script>
      tailwind.config = {
        darkMode: 'class',
        theme: {
          extend: {
            fontFamily: {
              'fjalla': ['"Fjalla One"', 'sans-serif'],
            },
            keyframes: {
              'finish-pulse': {
                '0%, 100%': { transform: 'scale(1)', boxShadow: '0 0 0 0 rgba(239, 68, 68, 0.7)' },
                '50%': { transform: 'scale(1.02)', boxShadow: '0 0 10px 10px rgba(239, 68, 68, 0)' },
              }
            },
            animation: {
              'finish-pulse': 'finish-pulse 2s infinite',
            }
          }
        }
      }
    </script>
    <!-- React and ReactDOM from CDN -->
    <script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
    <!-- Babel Standalone for JSX transpilation -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script type="importmap">
{
  "imports": {
    "react-dom/": "https://aistudiocdn.com/react-dom@^19.2.0/",
    "react/": "https://aistudiocdn.com/react@^19.2.0/",
    "react": "https://aistudiocdn.com/react@^19.2.0",
    "uuid": "https://aistudiocdn.com/uuid@^13.0.0"
  }
}
</script>
</head>
  <body class="bg-slate-100 dark:bg-slate-900">
    <div id="root"></div>
    <script type="text/babel" data-type="module">
// External dependencies
import { v4 as uuidv4 } from 'https://cdn.skypack.dev/uuid';

// React hooks
const { useState, useEffect, useCallback, useMemo, useRef } = React;

// --- From constants.ts ---
const CURRENCY_SYMBOL = 'â‚¹';

// --- From types.ts ---
const TimerStatus = {
  STOPPED: 0,
  RUNNING: 1,
  PAUSED: 2,
  FINISHED: 3,
};

/*
// Type definitions for reference
interface GamePreset {
  id: string;
  name: string;
  costPerUnit: number;
  minutesPerUnit: number;
}
interface TimerState {
  id: string;
  name: string;
  initialDuration: number; // in seconds
  remainingTime: number; // in seconds
  status: TimerStatus;
  costAnchor: number; // in seconds, represents remainingTime at last cost reset
  gamePresetId?: string;
}
interface StopwatchState {
  id:string;
  name: string;
  elapsedTime: number; // in seconds
  laps: number[];
  status: TimerStatus;
  costAnchor: number; // in seconds, represents elapsedTime at last cost reset
  gamePresetId?: string;
}
interface BillingRecord {
  id: string;
  date: string; // ISO string
  amount: number;
}
*/

// --- Shared Utility Functions ---
const formatTime = (totalSeconds) => {
  const absoluteSeconds = Math.abs(totalSeconds);
  const hours = Math.floor(absoluteSeconds / 3600);
  const minutes = Math.floor((absoluteSeconds % 3600) / 60);
  const seconds = Math.floor(absoluteSeconds % 60);
  const sign = totalSeconds < 0 ? '-' : '';
  return `${sign}${
    [hours, minutes, seconds]
      .map(v => v.toString().padStart(2, '0'))
      .join(':')
  }`;
};

// --- From components/icons.tsx ---
const iconProps = {
  viewBox: "0 0 24 24",
  fill: "none",
  stroke: "currentColor",
  strokeWidth: "2",
  strokeLinecap: "round",
  strokeLinejoin: "round",
};

const PlayIcon = () => React.createElement('svg', { ...iconProps, className: "w-6 h-6" }, React.createElement('polygon', { points: "5 3 19 12 5 21 5 3" }));
const PauseIcon = () => React.createElement('svg', { ...iconProps, className: "w-6 h-6" }, React.createElement('rect', { x: "6", y: "4", width: "4", height: "16" }), React.createElement('rect', { x: "14", y: "4", width: "4", height: "16" }));
const ResetIcon = () => React.createElement('svg', { ...iconProps, className: "w-6 h-6" }, React.createElement('polyline', { points: "23 4 23 10 17 10" }), React.createElement('path', { d: "M20.49 15a9 9 0 1 1-2.12-9.36L23 10" }));
const EditIcon = () => React.createElement('svg', { ...iconProps, className: "w-5 h-5" }, React.createElement('path', { d: "M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7" }), React.createElement('path', { d: "M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z" }));
const SaveIcon = () => React.createElement('svg', { ...iconProps, className: "w-5 h-5" }, React.createElement('path', { d: "M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z" }), React.createElement('polyline', { points: "17 21 17 13 7 13 7 21" }), React.createElement('polyline', { points: "7 3 7 8 15 8" }));
const DeleteIcon = () => React.createElement('svg', { ...iconProps, className: "w-5 h-5" }, React.createElement('polyline', { points: "3 6 5 6 21 6" }), React.createElement('path', { d: "M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2" }), React.createElement('line', { x1: "10", y1: "11", x2: "10", y2: "17" }), React.createElement('line', { x1: "14", y1: "11", x2: "14", y2: "17" }));
const PlusIcon = () => React.createElement('svg', { ...iconProps, className: "w-5 h-5" }, React.createElement('line', { x1: "12", y1: "5", x2: "12", y2: "19" }), React.createElement('line', { x1: "5", y1: "12", x2: "19", y2: "12" }));
const SunIcon = () => React.createElement('svg', { ...iconProps, className: "w-5 h-5" }, React.createElement('circle', { cx: "12", cy: "12", r: "5" }), React.createElement('line', { x1: "12", y1: "1", x2: "12", y2: "3" }), React.createElement('line', { x1: "12", y1: "21", x2: "12", y2: "23" }), React.createElement('line', { x1: "4.22", y1: "4.22", x2: "5.64", y2: "5.64" }), React.createElement('line', { x1: "18.36", y1: "18.36", x2: "19.78", y2: "19.78" }), React.createElement('line', { x1: "1", y1: "12", x2: "3", y2: "12" }), React.createElement('line', { x1: "21", y1: "12", x2: "23", y2: "12" }), React.createElement('line', { x1: "4.22", y1: "19.78", x2: "5.64", y2: "18.36" }), React.createElement('line', { x1: "18.36", y1: "5.64", x2: "19.78", y2: "4.22" }));
const MoonIcon = () => React.createElement('svg', { ...iconProps, className: "w-5 h-5" }, React.createElement('path', { d: "M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z" }));
const ClockIcon = () => React.createElement('svg', { ...iconProps, className: "w-5 h-5" }, React.createElement('circle', { cx: "12", cy: "12", r: "10" }), React.createElement('polyline', { points: "12 6 12 12 16 14" }));
const FlagIcon = () => React.createElement('svg', { ...iconProps, className: "w-6 h-6" }, React.createElement('path', { d: "M4 15s1-1 4-1 5 2 8 2 4-1 4-1V3s-1 1-4 1-5-2-8-2-4 1-4 1z" }), React.createElement('line', { x1: "4", y1: "22", x2: "4", y2: "15" }));
const SettingsIcon = () => React.createElement('svg', { ...iconProps, className: "w-5 h-5" }, React.createElement('circle', { cx: "12", cy: "12", r: "3" }), React.createElement('path', { d: "M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z" }));
const RotateCcwIcon = () => React.createElement('svg', { ...iconProps, className: "w-4 h-4" }, React.createElement('path', { d: "M3 2v6h6" }), React.createElement('path', { d: "M3.51 15a9 9 0 1 0 2.13-9.36L3 12" }));


// --- From components/TimerCard.tsx ---
const TimeEditModal = ({ isOpen, onClose, onSave, initialDuration }) => {
  const [hours, setHours] = useState(0);
  const [minutes, setMinutes] = useState(0);
  const [seconds, setSeconds] = useState(0);

  const parseDuration = useCallback((duration) => {
    setHours(Math.floor(duration / 3600));
    setMinutes(Math.floor((duration % 3600) / 60));
    setSeconds(duration % 60);
  }, []);

  useEffect(() => {
    if (isOpen) {
      parseDuration(initialDuration);
    }
  }, [isOpen, initialDuration, parseDuration]);
  
  const handleSave = () => {
    const totalSeconds = (hours * 3600) + (minutes * 60) + seconds;
    onSave(totalSeconds);
    onClose();
  };
  
  const handleNumberInput = (setter, max) => (e) => {
    let value = parseInt(e.target.value, 10);
    if (isNaN(value)) value = 0;
    if (value < 0) value = 0;
    if (value > max) value = max;
    setter(value);
  };

  if (!isOpen) return null;

  return (
    <div 
      className="fixed inset-0 bg-black/60 backdrop-blur-sm z-50 flex justify-center items-center p-4"
      onClick={onClose}
      role="dialog"
      aria-modal="true"
      aria-labelledby="time-edit-title"
    >
      <div 
        className="bg-white dark:bg-slate-800 rounded-lg shadow-xl p-6 w-full max-w-sm"
        onClick={e => e.stopPropagation()}
      >
        <h3 id="time-edit-title" className="text-xl font-bold mb-4 text-center">Set Timer Duration</h3>
        <div className="flex justify-center items-center space-x-2 sm:space-x-4 mb-6">
          <div className="text-center">
             <label htmlFor="hours-input" className="text-xs text-slate-500">Hours</label>
            <input 
              id="hours-input"
              type="number" 
              value={hours.toString().padStart(2, '0')} 
              onChange={handleNumberInput(setHours, 99)}
              className="w-20 sm:w-24 text-3xl sm:text-4xl font-mono bg-slate-100 dark:bg-slate-700 rounded-md text-center outline-none focus:ring-2 focus:ring-indigo-500"
              min="0"
              max="99"
            />
          </div>
          <span className="text-3xl sm:text-4xl font-mono text-slate-400 pt-5">:</span>
          <div className="text-center">
            <label htmlFor="minutes-input" className="text-xs text-slate-500">Minutes</label>
            <input 
              id="minutes-input"
              type="number" 
              value={minutes.toString().padStart(2, '0')} 
              onChange={handleNumberInput(setMinutes, 59)}
              className="w-20 sm:w-24 text-3xl sm:text-4xl font-mono bg-slate-100 dark:bg-slate-700 rounded-md text-center outline-none focus:ring-2 focus:ring-indigo-500"
              min="0"
              max="59"
            />
          </div>
          <span className="text-3xl sm:text-4xl font-mono text-slate-400 pt-5">:</span>
          <div className="text-center">
            <label htmlFor="seconds-input" className="text-xs text-slate-500">Seconds</label>
            <input 
              id="seconds-input"
              type="number" 
              value={seconds.toString().padStart(2, '0')} 
              onChange={handleNumberInput(setSeconds, 59)}
              className="w-20 sm:w-24 text-3xl sm:text-4xl font-mono bg-slate-100 dark:bg-slate-700 rounded-md text-center outline-none focus:ring-2 focus:ring-indigo-500"
              min="0"
              max="59"
            />
          </div>
        </div>
        <div className="flex justify-end space-x-3">
          <button 
            onClick={onClose}
            className="px-4 py-2 rounded-md text-slate-700 dark:text-slate-200 bg-slate-200 dark:bg-slate-600 hover:bg-slate-300 dark:hover:bg-slate-500 transition-colors"
          >
            Cancel
          </button>
          <button 
            onClick={handleSave}
            className="px-4 py-2 rounded-md text-white bg-indigo-600 hover:bg-indigo-700 transition-colors shadow-md"
          >
            Save
          </button>
        </div>
      </div>
    </div>
  );
};


const TimerCard = ({ timer, onUpdate, onDelete, onReset, costPerUnit, minutesPerUnit, gamePresets }) => {
  const { id, name, initialDuration, remainingTime, status, costAnchor, gamePresetId } = timer;
  const [isEditingName, setIsEditingName] = useState(false);
  const [tempName, setTempName] = useState(name);
  const [isTimeModalOpen, setIsTimeModalOpen] = useState(false);

  const intervalRef = useRef(null);
  const audioRef = useRef(null);

  useEffect(() => {
    // Alarm sound from a public domain source
    const soundUrl = 'https://cdn.pixabay.com/audio/2021/08/04/audio_12b0c7443c.mp3';
    audioRef.current = new Audio(soundUrl);
  }, []);

  useEffect(() => {
    if (status === TimerStatus.RUNNING) {
      intervalRef.current = window.setInterval(() => {
        onUpdate(id, { remainingTime: timer.remainingTime - 1 });
      }, 1000);
    } else {
      if (intervalRef.current) clearInterval(intervalRef.current);
    }
    
    if (remainingTime <= 0 && status === TimerStatus.RUNNING) {
      onUpdate(id, { status: TimerStatus.FINISHED, remainingTime: 0 });
      audioRef.current?.play();
    }

    return () => {
      if (intervalRef.current) clearInterval(intervalRef.current);
    };
  }, [status, remainingTime, onUpdate, id, timer.remainingTime]);
  
  const handleStart = () => onUpdate(id, { status: TimerStatus.RUNNING });
  const handlePause = () => onUpdate(id, { status: TimerStatus.PAUSED });
  
  const handleReset = () => {
    onReset(id);
  };
  
  const handleNameSave = () => {
    if (tempName.trim()) {
      onUpdate(id, { name: tempName.trim() });
    }
    setIsEditingName(false);
  };
  
  const handleTimeSave = (newDuration) => {
    if (status === TimerStatus.STOPPED && newDuration >= 0) {
        onUpdate(id, { 
          initialDuration: newDuration, 
          remainingTime: newDuration,
          costAnchor: newDuration
        });
    }
  };
  
  const handlePresetChange = (e) => {
    const selectedPresetId = e.target.value;
    onUpdate(id, { gamePresetId: selectedPresetId ? selectedPresetId : undefined });
  };

  const cost = useMemo(() => {
    const activePreset = gamePresets.find(p => p.id === gamePresetId);
    const currentCostPerUnit = activePreset ? activePreset.costPerUnit : costPerUnit;
    const currentMinutesPerUnit = activePreset ? activePreset.minutesPerUnit : minutesPerUnit;

    const elapsedTime = costAnchor - remainingTime;
    if (elapsedTime <= 0 || currentMinutesPerUnit === 0) return 0;
    
    const elapsedMinutes = elapsedTime / 60;
    return (elapsedMinutes / currentMinutesPerUnit) * currentCostPerUnit;
  }, [costAnchor, remainingTime, costPerUnit, minutesPerUnit, gamePresetId, gamePresets]);

  const progress = useMemo(() => {
    if (initialDuration === 0) return 0;
    return ((initialDuration - remainingTime) / initialDuration) * 100;
  }, [initialDuration, remainingTime]);

  const cardColorClasses = {
    [TimerStatus.STOPPED]: 'bg-white dark:bg-slate-800 border-slate-200 dark:border-slate-700',
    [TimerStatus.RUNNING]: 'bg-green-50 dark:bg-green-900/50 border-green-500',
    [TimerStatus.PAUSED]: 'bg-yellow-50 dark:bg-yellow-900/50 border-yellow-500',
    [TimerStatus.FINISHED]: 'bg-red-50 dark:bg-red-900/50 border-red-500 animate-finish-pulse',
  };

  return (
    <React.Fragment>
      <div className={`rounded-xl shadow-lg p-5 border-2 transition-all duration-300 flex flex-col ${cardColorClasses[status]}`}>
        <div className="flex justify-between items-center mb-2">
          {isEditingName ? (
            <input
              type="text"
              value={tempName}
              onChange={(e) => setTempName(e.target.value)}
              onBlur={handleNameSave}
              onKeyDown={(e) => e.key === 'Enter' && handleNameSave()}
              className="text-lg font-bold bg-transparent border-b-2 border-slate-400 focus:border-indigo-500 outline-none w-full mr-2"
              autoFocus
            />
          ) : (
            <h2 className="text-lg font-bold truncate" title={name}>{name}</h2>
          )}
          <div className="flex items-center space-x-2">
            <button onClick={() => isEditingName ? handleNameSave() : setIsEditingName(true)} className="text-slate-400 hover:text-indigo-500 dark:hover:text-indigo-400 transition-colors">
              {isEditingName ? <SaveIcon /> : <EditIcon />}
            </button>
            <button onClick={() => onDelete(id)} className="text-slate-400 hover:text-red-500 dark:hover:text-red-400 transition-colors">
              <DeleteIcon />
            </button>
          </div>
        </div>
        
        <div className="my-2 text-center">
            <div className="relative inline-flex items-center justify-center group">
                <p className={`text-4xl sm:text-5xl font-fjalla tracking-tighter ${status === TimerStatus.FINISHED ? 'text-red-500' : ''}`}>
                    {formatTime(remainingTime)}
                </p>
                {status === TimerStatus.STOPPED && (
                    <button
                        onClick={() => setIsTimeModalOpen(true)}
                        className="absolute left-full ml-2 p-1 text-slate-400 hover:text-indigo-500 dark:hover:text-indigo-400 transition-colors opacity-0 group-hover:opacity-100 focus:opacity-100"
                        aria-label="Edit duration"
                    >
                        <ClockIcon />
                    </button>
                )}
            </div>
        </div>
        
        <div className="mb-4">
          <label htmlFor={`preset-select-${id}`} className="sr-only">Select Game</label>
          <select
            id={`preset-select-${id}`}
            value={gamePresetId || ''}
            onChange={handlePresetChange}
            className="w-full bg-slate-100 dark:bg-slate-700 border border-slate-300 dark:border-slate-600 rounded-md p-1.5 text-sm outline-none focus:ring-2 focus:ring-indigo-500"
          >
            <option value="">Default Pricing</option>
            {gamePresets.map(preset => (
              <option key={preset.id} value={preset.id}>{preset.name}</option>
            ))}
          </select>
        </div>

        <div className="text-center mb-4">
          <p className="text-xl sm:text-2xl font-semibold text-indigo-600 dark:text-indigo-400">
              {CURRENCY_SYMBOL}{cost.toFixed(2)}
          </p>
          <p className="text-xs text-slate-400 dark:text-slate-500">
              {status === TimerStatus.FINISHED ? "Time Over!" : "Current Cost"}
          </p>
        </div>

        <div className="w-full bg-slate-200 dark:bg-slate-700 rounded-full h-2.5 mb-5">
          <div className="bg-indigo-600 dark:bg-indigo-500 h-2.5 rounded-full" style={{ width: `${progress}%` }}></div>
        </div>

        <div className="flex justify-center space-x-3 mt-auto">
          {(status === TimerStatus.STOPPED || status === TimerStatus.PAUSED || status === TimerStatus.FINISHED) && (
            <button onClick={handleStart} className="p-3 bg-green-500 text-white rounded-full hover:bg-green-600 transition-colors shadow-md disabled:bg-slate-400" disabled={remainingTime <= 0}>
              <PlayIcon />
            </button>
          )}
          {status === TimerStatus.RUNNING && (
            <button onClick={handlePause} className="p-3 bg-yellow-500 text-white rounded-full hover:bg-yellow-600 transition-colors shadow-md">
              <PauseIcon />
            </button>
          )}
          <button onClick={handleReset} className="p-3 bg-slate-500 text-white rounded-full hover:bg-slate-600 transition-colors shadow-md">
            <ResetIcon />
          </button>
        </div>
      </div>
      <TimeEditModal
          isOpen={isTimeModalOpen}
          onClose={() => setIsTimeModalOpen(false)}
          onSave={handleTimeSave}
          initialDuration={initialDuration}
      />
    </React.Fragment>
  );
};

// --- From components/StopwatchCard.tsx ---
const StopwatchCard = ({ stopwatch, onUpdate, onDelete, onReset, costPerUnit, minutesPerUnit, gamePresets }) => {
  const { id, name, elapsedTime, status, laps, costAnchor, gamePresetId } = stopwatch;
  const [isEditingName, setIsEditingName] = useState(false);
  const [tempName, setTempName] = useState(name);
  const intervalRef = useRef(null);

  useEffect(() => {
    if (status === TimerStatus.RUNNING) {
      intervalRef.current = window.setInterval(() => {
        onUpdate(id, { elapsedTime: stopwatch.elapsedTime + 1 });
      }, 1000);
    } else {
      if (intervalRef.current) clearInterval(intervalRef.current);
    }
    return () => {
      if (intervalRef.current) clearInterval(intervalRef.current);
    };
  }, [status, onUpdate, id, stopwatch.elapsedTime]);
  
  const handleStart = () => onUpdate(id, { status: TimerStatus.RUNNING });
  const handlePause = () => onUpdate(id, { status: TimerStatus.PAUSED });
  const handleReset = () => onReset(id);
  
  const handleNameSave = () => {
    if (tempName.trim()) {
      onUpdate(id, { name: tempName.trim() });
    }
    setIsEditingName(false);
  };
  
  const handleLap = () => {
    if (status === TimerStatus.RUNNING) {
      onUpdate(id, { laps: [...laps, elapsedTime] });
    }
  };

  const handlePresetChange = (e) => {
    const selectedPresetId = e.target.value;
    onUpdate(id, { gamePresetId: selectedPresetId ? selectedPresetId : undefined });
  };

  const cost = useMemo(() => {
    const activePreset = gamePresets.find(p => p.id === gamePresetId);
    const currentCostPerUnit = activePreset ? activePreset.costPerUnit : costPerUnit;
    const currentMinutesPerUnit = activePreset ? activePreset.minutesPerUnit : minutesPerUnit;
    
    const costElapsedTime = elapsedTime - costAnchor;
    if (costElapsedTime <= 0 || currentMinutesPerUnit === 0) return 0;

    const elapsedMinutes = costElapsedTime / 60;
    return (elapsedMinutes / currentMinutesPerUnit) * currentCostPerUnit;
  }, [elapsedTime, costAnchor, costPerUnit, minutesPerUnit, gamePresetId, gamePresets]);
  
  const cardColorClasses = {
    [TimerStatus.STOPPED]: 'bg-white dark:bg-slate-800 border-slate-200 dark:border-slate-700',
    [TimerStatus.RUNNING]: 'bg-sky-50 dark:bg-sky-900/50 border-sky-500',
    [TimerStatus.PAUSED]: 'bg-yellow-50 dark:bg-yellow-900/50 border-yellow-500',
    [TimerStatus.FINISHED]: 'bg-white dark:bg-slate-800 border-slate-200 dark:border-slate-700', // Not used, but for enum completeness
  };

  return (
    <div className={`rounded-xl shadow-lg p-5 border-2 transition-all duration-300 flex flex-col ${cardColorClasses[status]}`}>
      <div className="flex justify-between items-center mb-2">
        {isEditingName ? (
          <input
            type="text"
            value={tempName}
            onChange={(e) => setTempName(e.target.value)}
            onBlur={handleNameSave}
            onKeyDown={(e) => e.key === 'Enter' && handleNameSave()}
            className="text-lg font-bold bg-transparent border-b-2 border-slate-400 focus:border-indigo-500 outline-none w-full mr-2"
            autoFocus
          />
        ) : (
          <h2 className="text-lg font-bold truncate" title={name}>{name}</h2>
        )}
        <div className="flex items-center space-x-2">
          <button onClick={() => isEditingName ? handleNameSave() : setIsEditingName(true)} className="text-slate-400 hover:text-indigo-500 dark:hover:text-indigo-400 transition-colors" aria-label={isEditingName ? 'Save name' : 'Edit name'}>
            {isEditingName ? <SaveIcon /> : <EditIcon />}
          </button>
          <button onClick={() => onDelete(id)} className="text-slate-400 hover:text-red-500 dark:hover:text-red-400 transition-colors" aria-label="Delete stopwatch">
            <DeleteIcon />
          </button>
        </div>
      </div>
      
      <div className="my-2 text-center">
          <p className="text-4xl sm:text-5xl font-fjalla tracking-tighter">
              {formatTime(elapsedTime)}
          </p>
      </div>

      <div className="mb-4">
        <label htmlFor={`preset-select-${id}`} className="sr-only">Select Game</label>
        <select
          id={`preset-select-${id}`}
          value={gamePresetId || ''}
          onChange={handlePresetChange}
          className="w-full bg-slate-100 dark:bg-slate-700 border border-slate-300 dark:border-slate-600 rounded-md p-1.5 text-sm outline-none focus:ring-2 focus:ring-indigo-500"
        >
          <option value="">Default Pricing</option>
          {gamePresets.map(preset => (
            <option key={preset.id} value={preset.id}>{preset.name}</option>
          ))}
        </select>
      </div>

      <div className="text-center mb-4">
        <p className="text-xl sm:text-2xl font-semibold text-indigo-600 dark:text-indigo-400">
            {CURRENCY_SYMBOL}{cost.toFixed(2)}
        </p>
        <p className="text-xs text-slate-400 dark:text-slate-500">Current Cost</p>
      </div>
      
      {laps.length > 0 && (
        <div className="mb-4 border-t border-slate-200 dark:border-slate-700 pt-3 max-h-24 overflow-y-auto">
          <ol className="text-sm text-slate-500 dark:text-slate-400 space-y-1 pr-2">
            {laps.slice().reverse().map((lap, index) => (
                <li key={index} className="flex justify-between items-center">
                    <span>Lap {laps.length - index}</span>
                    <span className="font-mono">{formatTime(lap)}</span>
                </li>
            ))}
          </ol>
        </div>
      )}

      <div className="flex justify-center space-x-3 mt-auto">
        {(status === TimerStatus.STOPPED || status === TimerStatus.PAUSED) && (
          <button onClick={handleStart} className="p-3 bg-green-500 text-white rounded-full hover:bg-green-600 transition-colors shadow-md" aria-label="Start stopwatch">
            <PlayIcon />
          </button>
        )}
        {status === TimerStatus.RUNNING && (
          <button onClick={handlePause} className="p-3 bg-yellow-500 text-white rounded-full hover:bg-yellow-600 transition-colors shadow-md" aria-label="Pause stopwatch">
            <PauseIcon />
          </button>
        )}
        <button onClick={handleReset} className="p-3 bg-slate-500 text-white rounded-full hover:bg-slate-600 transition-colors shadow-md" aria-label="Reset stopwatch">
          <ResetIcon />
        </button>
        <button onClick={handleLap} className="p-3 bg-indigo-500 text-white rounded-full hover:bg-indigo-600 transition-colors shadow-md disabled:bg-slate-400 disabled:cursor-not-allowed" disabled={status !== TimerStatus.RUNNING} aria-label="Record lap">
          <FlagIcon />
        </button>
      </div>
    </div>
  );
};

// --- From components/SettingsModal.tsx ---
const SettingsModal = ({ isOpen, onClose, onSave, initialCost, initialMinutes, initialPresets }) => {
  const [activeTab, setActiveTab] = useState('default');
  const [cost, setCost] = useState(initialCost);
  const [minutes, setMinutes] = useState(initialMinutes);
  const [presets, setPresets] = useState([]);
  const [editingPreset, setEditingPreset] = useState(null);

  useEffect(() => {
    if (isOpen) {
      setCost(initialCost);
      setMinutes(initialMinutes);
      setPresets(JSON.parse(JSON.stringify(initialPresets))); // Deep copy
      setEditingPreset(null);
      setActiveTab('default');
    }
  }, [isOpen, initialCost, initialMinutes, initialPresets]);

  const handleSave = () => {
    onSave(cost, minutes, presets);
    onClose();
  };

  const handleAddNewPreset = () => {
    setEditingPreset({
      id: uuidv4(),
      name: '',
      costPerUnit: cost,
      minutesPerUnit: minutes,
    });
  };

  const handleSavePreset = () => {
    if (!editingPreset || !editingPreset.name || !editingPreset.id) return;

    const existing = presets.find(p => p.id === editingPreset.id);
    if (existing) {
      setPresets(presets.map(p => p.id === editingPreset.id ? editingPreset : p));
    } else {
      setPresets([...presets, editingPreset]);
    }
    setEditingPreset(null);
  };

  const handleDeletePreset = (id) => {
    if (window.confirm("Are you sure you want to delete this game preset?")) {
      setPresets(presets.filter(p => p.id !== id));
    }
  };

  const handleNumberInput = (setter, min) => (e) => {
    let value = parseInt(e.target.value, 10);
    if (isNaN(value)) value = min;
    if (value < min) value = min;
    setter(value);
  };

  const tabButtonClasses = (tabName) =>
    `px-4 py-2 text-sm font-medium rounded-t-md transition-colors focus:outline-none focus-visible:ring-2 focus-visible:ring-offset-2 focus-visible:ring-indigo-500 dark:focus-visible:ring-offset-slate-800 ${
      activeTab === tabName
        ? 'bg-white dark:bg-slate-800 text-indigo-600 dark:text-indigo-400 border-b-0'
        : 'bg-slate-100 dark:bg-slate-700 text-slate-500 dark:text-slate-400 hover:bg-slate-200 dark:hover:bg-slate-600'
    }`;
  
  if (!isOpen) return null;

  const renderPresetForm = () => (
    <div className="bg-slate-200 dark:bg-slate-900/50 p-3 rounded-lg space-y-3">
      <input
        type="text"
        placeholder="Game Name"
        value={editingPreset?.name || ''}
        onChange={(e) => setEditingPreset(p => ({...p, name: e.target.value}))}
        className="w-full text-base bg-white dark:bg-slate-700 rounded-md p-2 outline-none focus:ring-2 focus:ring-indigo-500"
        autoFocus
      />
      <div className="flex gap-3">
        <input
          type="number"
          placeholder="Cost"
          value={editingPreset?.costPerUnit ?? ''}
          onChange={(e) => setEditingPreset(p => ({...p, costPerUnit: parseInt(e.target.value, 10) || 0}))}
          className="w-1/2 text-base bg-white dark:bg-slate-700 rounded-md p-2 outline-none focus:ring-2 focus:ring-indigo-500"
        />
        <input
          type="number"
          placeholder="Minutes"
          value={editingPreset?.minutesPerUnit ?? ''}
          onChange={(e) => setEditingPreset(p => ({...p, minutesPerUnit: parseInt(e.target.value, 10) || 0}))}
          className="w-1/2 text-base bg-white dark:bg-slate-700 rounded-md p-2 outline-none focus:ring-2 focus:ring-indigo-500"
        />
      </div>
      <div className="flex justify-end gap-2">
        <button onClick={() => setEditingPreset(null)} className="px-3 py-1 text-sm rounded-md text-slate-700 dark:text-slate-200 bg-slate-300 dark:bg-slate-600 hover:bg-slate-400 dark:hover:bg-slate-500">Cancel</button>
        <button onClick={handleSavePreset} className="px-3 py-1 text-sm rounded-md text-white bg-indigo-600 hover:bg-indigo-700">Save</button>
      </div>
    </div>
  );

  return (
    <div
      className="fixed inset-0 bg-black/60 backdrop-blur-sm z-50 flex justify-center items-center p-4"
      onClick={onClose}
      role="dialog"
      aria-modal="true"
      aria-labelledby="settings-title"
    >
      <div
        className="bg-slate-100 dark:bg-slate-900 rounded-lg shadow-xl w-full max-w-md"
        onClick={e => e.stopPropagation()}
      >
        <div className="px-6 pt-6">
          <h3 id="settings-title" className="text-xl font-bold mb-4 text-center">Pricing Settings</h3>
          <div className="border-b border-slate-300 dark:border-slate-700 -mb-px">
            <nav className="flex space-x-2" aria-label="Tabs">
              <button onClick={() => setActiveTab('default')} className={tabButtonClasses('default')}>Default</button>
              <button onClick={() => setActiveTab('games')} className={tabButtonClasses('games')}>Game Presets</button>
            </nav>
          </div>
        </div>

        <div className="bg-white dark:bg-slate-800 p-6 rounded-b-lg">
          {activeTab === 'default' && (
            <div className="space-y-4">
               <div>
                <label htmlFor="cost-input" className="block text-sm font-medium text-slate-700 dark:text-slate-300 mb-1">Default Cost</label>
                <div className="relative">
                  <div className="pointer-events-none absolute inset-y-0 left-0 flex items-center pl-3">
                    <span className="text-slate-500 sm:text-sm">{CURRENCY_SYMBOL}</span>
                  </div>
                  <input
                    id="cost-input"
                    type="number"
                    value={cost}
                    onChange={handleNumberInput(setCost, 1)}
                    className="w-full text-lg font-mono bg-slate-100 dark:bg-slate-700 rounded-md text-center py-2 pl-7 pr-4 outline-none focus:ring-2 focus:ring-indigo-500"
                    min="1"
                  />
                </div>
              </div>
              <div>
                <label htmlFor="minutes-input" className="block text-sm font-medium text-slate-700 dark:text-slate-300 mb-1">Per Minutes</label>
                <div className="relative">
                  <input
                    id="minutes-input"
                    type="number"
                    value={minutes}
                    onChange={handleNumberInput(setMinutes, 1)}
                    className="w-full text-lg font-mono bg-slate-100 dark:bg-slate-700 rounded-md text-center py-2 outline-none focus:ring-2 focus:ring-indigo-500"
                    min="1"
                  />
                  <div className="pointer-events-none absolute inset-y-0 right-0 flex items-center pr-3">
                    <span className="text-slate-500 sm:text-sm">min</span>
                  </div>
                </div>
              </div>
            </div>
          )}

          {activeTab === 'games' && (
            <div className="space-y-4">
              {presets.length > 0 && (
                <ul className="space-y-2 max-h-60 overflow-y-auto pr-2">
                  {presets.map(p => (
                    <li key={p.id} className="flex justify-between items-center bg-slate-100 dark:bg-slate-700 p-2 rounded-md">
                      <div>
                        <p className="font-semibold">{p.name}</p>
                        <p className="text-sm text-slate-500 dark:text-slate-400">{CURRENCY_SYMBOL}{p.costPerUnit} / {p.minutesPerUnit} min</p>
                      </div>
                      <div className="flex gap-2">
                        <button onClick={() => setEditingPreset(p)} className="text-slate-500 hover:text-indigo-500"><EditIcon /></button>
                        <button onClick={() => handleDeletePreset(p.id)} className="text-slate-500 hover:text-red-500"><DeleteIcon /></button>
                      </div>
                    </li>
                  ))}
                </ul>
              )}
              {editingPreset ? renderPresetForm() : (
                <button onClick={handleAddNewPreset} className="w-full flex items-center justify-center gap-2 py-2 px-4 rounded-md text-white bg-indigo-600 hover:bg-indigo-700 transition-colors shadow-sm">
                  <PlusIcon /> Add New Game
                </button>
              )}
            </div>
          )}
          
          <div className="flex justify-end space-x-3 mt-6">
            <button
              onClick={onClose}
              className="px-4 py-2 rounded-md text-slate-700 dark:text-slate-200 bg-slate-200 dark:bg-slate-600 hover:bg-slate-300 dark:hover:bg-slate-500 transition-colors"
            >
              Cancel
            </button>
            <button
              onClick={handleSave}
              className="px-4 py-2 rounded-md text-white bg-green-600 hover:bg-green-700 transition-colors shadow-md"
            >
              Save Changes
            </button>
          </div>
        </div>
      </div>
    </div>
  );
};

// --- From components/BillingModal.tsx ---
const BillingModal = ({ isOpen, onClose, onConfirm, totalEarnings }) => {
  if (!isOpen) return null;

  return (
    <div 
      className="fixed inset-0 bg-black/60 backdrop-blur-sm z-50 flex justify-center items-center p-4"
      onClick={onClose}
      role="dialog"
      aria-modal="true"
      aria-labelledby="billing-title"
    >
      <div 
        className="bg-white dark:bg-slate-800 rounded-lg shadow-xl p-6 w-full max-w-sm"
        onClick={e => e.stopPropagation()}
      >
        <h3 id="billing-title" className="text-xl font-bold mb-4 text-center">Reset & Bill Session</h3>
        <p className="text-center text-slate-500 dark:text-slate-400 mb-6">
          This will save the current total earnings to history and reset the amount to zero for the next session.
        </p>
        
        <div className="text-center bg-slate-100 dark:bg-slate-700 p-4 rounded-lg mb-6">
          <p className="text-sm text-slate-600 dark:text-slate-300">Total to be Billed</p>
          <p className="text-3xl sm:text-4xl font-bold text-indigo-600 dark:text-indigo-400">
            {CURRENCY_SYMBOL}{totalEarnings.toFixed(2)}
          </p>
        </div>

        <div className="flex justify-end space-x-3">
          <button 
            onClick={onClose}
            className="px-4 py-2 rounded-md text-slate-700 dark:text-slate-200 bg-slate-200 dark:bg-slate-600 hover:bg-slate-300 dark:hover:bg-slate-500 transition-colors"
          >
            Cancel
          </button>
          <button 
            onClick={onConfirm}
            className="px-4 py-2 rounded-md text-white bg-green-600 hover:bg-green-700 transition-colors shadow-md"
          >
            Reset & Bill
          </button>
        </div>
      </div>
    </div>
  );
};

// --- From components/HistoryView.tsx ---
const HistoryView = ({ history, onClearHistory }) => {
  const totalBilled = history.reduce((acc, record) => acc + record.amount, 0);

  if (history.length === 0) {
    return (
      <div className="text-center py-20">
        <h2 className="text-2xl font-semibold text-slate-500 dark:text-slate-400">No billing history yet.</h2>
        <p className="text-slate-400 dark:text-slate-500 mt-2">When you "Reset & Bill", the records will appear here.</p>
      </div>
    );
  }

  return (
    <div className="max-w-4xl mx-auto">
      <div className="flex flex-col items-start gap-4 sm:flex-row sm:justify-between sm:items-center mb-6">
        <div>
           <h2 className="text-2xl font-bold">Billing History</h2>
           <p className="text-slate-500 dark:text-slate-400">Total Billed: <span className="font-semibold text-indigo-600 dark:text-indigo-400">{CURRENCY_SYMBOL}{totalBilled.toFixed(2)}</span></p>
        </div>
        <button
          onClick={onClearHistory}
          className="px-4 py-2 rounded-md text-white bg-red-600 hover:bg-red-700 transition-colors shadow-sm text-sm"
        >
          Clear History
        </button>
      </div>

      <div className="bg-white dark:bg-slate-800 rounded-lg shadow-md overflow-hidden">
        <ul className="divide-y divide-slate-200 dark:divide-slate-700">
          {history.map(record => (
            <li key={record.id} className="p-4 flex justify-between items-center hover:bg-slate-50 dark:hover:bg-slate-700/50 transition-colors">
              <div>
                <p className="font-semibold">
                  {new Date(record.date).toLocaleDateString(undefined, {
                    year: 'numeric',
                    month: 'long',
                    day: 'numeric',
                  })}
                </p>
                <p className="text-sm text-slate-500 dark:text-slate-400">
                  {new Date(record.date).toLocaleTimeString()}
                </p>
              </div>
              <p className="text-lg font-mono font-semibold text-green-600 dark:text-green-400">
                {CURRENCY_SYMBOL}{record.amount.toFixed(2)}
              </p>
            </li>
          ))}
        </ul>
      </div>
    </div>
  );
};

// --- From components/Header.tsx ---
const Header = ({ 
  onAddTimer, 
  onAddStopwatch, 
  totalEarnings, 
  theme, 
  toggleTheme, 
  activeTab, 
  setActiveTab,
  onOpenSettings,
  onResetEarnings
}) => {
  const [currentTime, setCurrentTime] = useState(new Date());

  useEffect(() => {
    const timerId = setInterval(() => {
      setCurrentTime(new Date());
    }, 1000);
    return () => clearInterval(timerId);
  }, []);

  const formattedTime = currentTime.toLocaleTimeString('en-US', {
    hour: '2-digit',
    minute: '2-digit',
    second: '2-digit',
    hour12: true,
  });

  const tabButtonClasses = (tabName) => 
    `px-2 py-1.5 text-xs sm:text-sm font-medium rounded-md transition-colors ${
      activeTab === tabName
        ? 'bg-indigo-600 text-white'
        : 'text-slate-500 hover:bg-slate-200 dark:text-slate-400 dark:hover:bg-slate-700'
    }`;

  return (
    <header className="bg-white/80 dark:bg-slate-900/80 backdrop-blur-sm sticky top-0 z-10 border-b border-slate-200 dark:border-slate-800 shadow-sm">
      <div className="container mx-auto px-4 sm:px-6 lg:px-8">
        <div className="flex items-center justify-between min-h-[4rem]">
          <div className="flex items-center space-x-2 sm:space-x-4">
            <h1 className="text-xl sm:text-2xl font-bold text-indigo-600 dark:text-indigo-400">
              X Timer
            </h1>
            <div className="hidden sm:block text-sm font-mono bg-slate-200 dark:bg-slate-700 px-3 py-1.5 rounded-md text-slate-600 dark:text-slate-300">
              {formattedTime}
            </div>
            <div className="bg-slate-200 dark:bg-slate-700 p-1 rounded-lg flex space-x-1">
              <button onClick={() => setActiveTab('timers')} className={tabButtonClasses('timers')}>
                  Timers
              </button>
              <button onClick={() => setActiveTab('stopwatches')} className={tabButtonClasses('stopwatches')}>
                  Stopwatches
              </button>
               <button onClick={() => setActiveTab('history')} className={tabButtonClasses('history')}>
                  History
              </button>
            </div>
          </div>
          <div className="flex items-center space-x-1 sm:space-x-2">
            <div className="text-center hidden md:flex items-center gap-2">
              <div>
                <span className="text-xs text-slate-500 dark:text-slate-400">Total Earnings</span>
                <p className="font-bold text-lg">{CURRENCY_SYMBOL}{totalEarnings.toFixed(2)}</p>
              </div>
               <button
                onClick={onResetEarnings}
                className="p-1 rounded-full text-slate-500 dark:text-slate-400 hover:bg-slate-200 dark:hover:bg-slate-700 transition-colors"
                aria-label="Reset total earnings"
              >
                <RotateCcwIcon />
              </button>
            </div>
             <button
              onClick={onOpenSettings}
              className="p-2 rounded-full text-slate-500 dark:text-slate-400 hover:bg-slate-200 dark:hover:bg-slate-700 transition-colors"
              aria-label="Open settings"
            >
              <SettingsIcon />
            </button>
            <button
              onClick={toggleTheme}
              className="p-2 rounded-full text-slate-500 dark:text-slate-400 hover:bg-slate-200 dark:hover:bg-slate-700 transition-colors"
              aria-label="Toggle theme"
            >
              {theme === 'light' ? <MoonIcon /> : <SunIcon />}
            </button>
            {activeTab !== 'history' && (
               <button
                onClick={activeTab === 'timers' ? onAddTimer : onAddStopwatch}
                className="flex items-center justify-center bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-2 sm:px-4 rounded-lg transition-colors shadow-md"
              >
                <PlusIcon />
                <span className="hidden sm:inline ml-1 sm:ml-2">
                  {activeTab === 'timers' ? 'Add Timer' : 'Add Stopwatch'}
                </span>
              </button>
            )}
          </div>
        </div>
      </div>
    </header>
  );
};


// --- From App.tsx ---
const ConfirmationModal = ({ 
  isOpen, 
  onClose, 
  onConfirm, 
  title, 
  message, 
  confirmButtonText = 'Confirm',
  confirmButtonClass = 'bg-red-600 hover:bg-red-700'
}) => {
  if (!isOpen) return null;

  return (
    <div 
      className="fixed inset-0 bg-black/60 backdrop-blur-sm z-50 flex justify-center items-center p-4"
      onClick={onClose}
      role="dialog"
      aria-modal="true"
      aria-labelledby="confirmation-title"
    >
      <div 
        className="bg-white dark:bg-slate-800 rounded-lg shadow-xl p-6 w-full max-w-sm"
        onClick={e => e.stopPropagation()}
      >
        <h3 id="confirmation-title" className="text-xl font-bold mb-4 text-center">{title}</h3>
        <p className="text-center text-slate-500 dark:text-slate-400 mb-6">
          {message}
        </p>
        
        <div className="flex justify-end space-x-3">
          <button 
            onClick={onClose}
            className="px-4 py-2 rounded-md text-slate-700 dark:text-slate-200 bg-slate-200 dark:bg-slate-600 hover:bg-slate-300 dark:hover:bg-slate-500 transition-colors"
          >
            Cancel
          </button>
          <button 
            onClick={onConfirm}
            className={`px-4 py-2 rounded-md text-white transition-colors shadow-md ${confirmButtonClass}`}
          >
            {confirmButtonText}
          </button>
        </div>
      </div>
    </div>
  );
};

const App = () => {
  const [timers, setTimers] = useState([]);
  const [stopwatches, setStopwatches] = useState([]);
  const [bankedEarnings, setBankedEarnings] = useState(0);
  const [billingHistory, setBillingHistory] = useState([]);
  const [activeTab, setActiveTab] = useState('timers');
  const [costPerUnit, setCostPerUnit] = useState(50);
  const [minutesPerUnit, setMinutesPerUnit] = useState(10);
  const [gamePresets, setGamePresets] = useState([]);
  const [isSettingsOpen, setIsSettingsOpen] = useState(false);
  const [isBillingModalOpen, setIsBillingModalOpen] = useState(false);
  const [isClearHistoryConfirmOpen, setIsClearHistoryConfirmOpen] = useState(false);
  const [theme, setTheme] = useState(() => {
    if (typeof window !== 'undefined' && window.localStorage) {
      const storedTheme = window.localStorage.getItem('theme');
      if (storedTheme === 'dark' || storedTheme === 'light') {
        return storedTheme;
      }
      return window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light';
    }
    return 'light';
  });

  useEffect(() => {
    try {
      const savedTimers = localStorage.getItem('x-timers');
      if (savedTimers) {
          const parsedTimers = JSON.parse(savedTimers);
          setTimers(parsedTimers.map(t => ({
              ...t,
              costAnchor: t.costAnchor ?? t.initialDuration
          })));
      }
      
      const savedStopwatches = localStorage.getItem('x-stopwatches');
      if (savedStopwatches) {
          const parsedStopwatches = JSON.parse(savedStopwatches);
          setStopwatches(parsedStopwatches.map(s => ({
              ...s,
              costAnchor: s.costAnchor ?? 0
          })));
      }

      const savedEarnings = localStorage.getItem('x-timers-banked');
      if (savedEarnings) setBankedEarnings(JSON.parse(savedEarnings));
      
      const savedHistory = localStorage.getItem('x-timers-billing-history');
      if (savedHistory) setBillingHistory(JSON.parse(savedHistory));

      const savedCost = localStorage.getItem('x-timers-cost');
      if (savedCost) setCostPerUnit(JSON.parse(savedCost));

      const savedMinutes = localStorage.getItem('x-timers-minutes');
      if (savedMinutes) setMinutesPerUnit(JSON.parse(savedMinutes));
      
      const savedPresets = localStorage.getItem('x-timers-game-presets');
      if (savedPresets) setGamePresets(JSON.parse(savedPresets));

    } catch (error) {
      console.error("Failed to load data from localStorage", error);
    }
  }, []);

  useEffect(() => { localStorage.setItem('x-timers', JSON.stringify(timers)); }, [timers]);
  useEffect(() => { localStorage.setItem('x-stopwatches', JSON.stringify(stopwatches)); }, [stopwatches]);
  useEffect(() => { localStorage.setItem('x-timers-banked', JSON.stringify(bankedEarnings)); }, [bankedEarnings]);
  useEffect(() => { localStorage.setItem('x-timers-billing-history', JSON.stringify(billingHistory)); }, [billingHistory]);
  useEffect(() => { localStorage.setItem('x-timers-cost', JSON.stringify(costPerUnit)); }, [costPerUnit]);
  useEffect(() => { localStorage.setItem('x-timers-minutes', JSON.stringify(minutesPerUnit)); }, [minutesPerUnit]);
  useEffect(() => { localStorage.setItem('x-timers-game-presets', JSON.stringify(gamePresets)); }, [gamePresets]);

  useEffect(() => {
    if (theme === 'dark') {
      document.documentElement.classList.add('dark');
    } else {
      document.documentElement.classList.remove('dark');
    }
    localStorage.setItem('theme', theme);
  }, [theme]);

  const toggleTheme = () => {
    setTheme(prevTheme => prevTheme === 'light' ? 'dark' : 'light');
  };

  const addTimer = useCallback(() => {
    const newDuration = minutesPerUnit * 60;
    const newTimer = {
      id: uuidv4(),
      name: `Station ${timers.length + 1}`,
      initialDuration: newDuration,
      remainingTime: newDuration,
      status: TimerStatus.STOPPED,
      costAnchor: newDuration,
    };
    setTimers(prev => [...prev, newTimer]);
  }, [timers.length, minutesPerUnit]);

  const updateTimer = useCallback((id, updates) => {
    setTimers(prev =>
      prev.map(timer => (timer.id === id ? { ...timer, ...updates } : timer))
    );
  }, []);

  const deleteTimer = useCallback((id) => {
    setTimers(prev => prev.filter(timer => timer.id !== id));
  }, []);

  const getPricing = useCallback((gamePresetId) => {
    if (gamePresetId) {
        const preset = gamePresets.find(p => p.id === gamePresetId);
        if (preset) {
            return { cost: preset.costPerUnit, minutes: preset.minutesPerUnit };
        }
    }
    return { cost: costPerUnit, minutes: minutesPerUnit };
  }, [gamePresets, costPerUnit, minutesPerUnit]);

  const handleTimerReset = useCallback((id) => {
    const timerToReset = timers.find(t => t.id === id);
    if (!timerToReset) return;

    const { cost, minutes } = getPricing(timerToReset.gamePresetId);
    const elapsedTime = timerToReset.costAnchor - timerToReset.remainingTime;
    if (elapsedTime > 0) {
      const elapsedMinutes = elapsedTime / 60;
      const costFromSession = (elapsedMinutes / minutes) * cost;
      setBankedEarnings(prev => prev + costFromSession);
    }

    updateTimer(id, {
      status: TimerStatus.STOPPED,
      remainingTime: timerToReset.initialDuration,
      costAnchor: timerToReset.initialDuration,
    });
  }, [timers, updateTimer, getPricing]);
  
  const handleOpenBillingModal = () => {
    if (totalEarnings > 0.01) {
        setIsBillingModalOpen(true);
    } else {
        alert("Total earnings are zero. Nothing to bill.");
    }
  };

  const handleResetAndBill = () => {
    if (totalEarnings <= 0) {
        setIsBillingModalOpen(false);
        return;
    }

    const newRecord = {
        id: uuidv4(),
        date: new Date().toISOString(),
        amount: totalEarnings,
    };
    setBillingHistory(prev => [newRecord, ...prev]);

    setBankedEarnings(0);
    setTimers(prevTimers =>
        prevTimers.map(timer => ({
            ...timer,
            costAnchor: timer.remainingTime,
        }))
    );
    setStopwatches(prevStopwatches =>
        prevStopwatches.map(sw => ({
            ...sw,
            costAnchor: sw.elapsedTime,
        }))
    );

    setIsBillingModalOpen(false);
  };

  const handleClearHistory = () => {
    setIsClearHistoryConfirmOpen(true);
  };

  const confirmClearHistory = () => {
    setBillingHistory([]);
    setIsClearHistoryConfirmOpen(false);
  };


  const addStopwatch = useCallback(() => {
    const newStopwatch = {
      id: uuidv4(),
      name: `Stopwatch ${stopwatches.length + 1}`,
      elapsedTime: 0,
      laps: [],
      status: TimerStatus.STOPPED,
      costAnchor: 0,
    };
    setStopwatches(prev => [...prev, newStopwatch]);
  }, [stopwatches.length]);

  const updateStopwatch = useCallback((id, updates) => {
    setStopwatches(prev =>
      prev.map(sw => (sw.id === id ? { ...sw, ...updates } : sw))
    );
  }, []);

  const deleteStopwatch = useCallback((id) => {
    setStopwatches(prev => prev.filter(sw => sw.id !== id));
  }, []);

  const handleStopwatchReset = useCallback((id) => {
    const swToReset = stopwatches.find(sw => sw.id === id);
    if (!swToReset) return;
    
    const { cost, minutes } = getPricing(swToReset.gamePresetId);
    const costElapsedTime = swToReset.elapsedTime - swToReset.costAnchor;
    if (costElapsedTime > 0) {
      const elapsedMinutes = costElapsedTime / 60;
      const costFromSession = (elapsedMinutes / minutes) * cost;
      setBankedEarnings(prev => prev + costFromSession);
    }

    updateStopwatch(id, {
      status: TimerStatus.STOPPED,
      elapsedTime: 0,
      laps: [],
      costAnchor: 0,
    });
  }, [stopwatches, updateStopwatch, getPricing]);

  const totalEarnings = useMemo(() => {
    const currentTimersCost = timers.reduce((total, timer) => {
      const { cost, minutes } = getPricing(timer.gamePresetId);
      const elapsedTime = timer.costAnchor - timer.remainingTime;
      if (elapsedTime <= 0 || minutes === 0) return total;
      const elapsedMinutes = elapsedTime / 60;
      const sessionCost = (elapsedMinutes / minutes) * cost;
      return total + sessionCost;
    }, 0);

    const currentStopwatchesCost = stopwatches.reduce((total, sw) => {
      const { cost, minutes } = getPricing(sw.gamePresetId);
      const costElapsedTime = sw.elapsedTime - sw.costAnchor;
      if (costElapsedTime <= 0 || minutes === 0) return total;
      const elapsedMinutes = costElapsedTime / 60;
      const sessionCost = (elapsedMinutes / minutes) * cost;
      return total + sessionCost;
    }, 0);

    return bankedEarnings + currentTimersCost + currentStopwatchesCost;
  }, [timers, stopwatches, bankedEarnings, getPricing]);
  
  const handleSaveSettings = (newCost, newMinutes, newPresets) => {
    setCostPerUnit(newCost);
    setMinutesPerUnit(newMinutes);
    setGamePresets(newPresets);
  };

  return (
    <div className="min-h-screen text-slate-800 dark:text-slate-200 transition-colors duration-300">
      <Header 
        onAddTimer={addTimer} 
        onAddStopwatch={addStopwatch}
        totalEarnings={totalEarnings}
        theme={theme}
        toggleTheme={toggleTheme}
        activeTab={activeTab}
        setActiveTab={setActiveTab}
        onOpenSettings={() => setIsSettingsOpen(true)}
        onResetEarnings={handleOpenBillingModal}
      />
      <main className="container mx-auto p-4 sm:p-6 lg:p-8">
        {activeTab === 'timers' && (
          <React.Fragment>
            {timers.length === 0 ? (
              <div className="text-center py-20">
                <h2 className="text-2xl font-semibold text-slate-500 dark:text-slate-400">No timers yet.</h2>
                <p className="text-slate-400 dark:text-slate-500 mt-2">Click "Add Timer" to get started!</p>
              </div>
            ) : (
              <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-4 sm:gap-6 lg:gap-8">
                {timers.map(timer => (
                  <TimerCard
                    key={timer.id}
                    timer={timer}
                    onUpdate={updateTimer}
                    onDelete={deleteTimer}
                    onReset={handleTimerReset}
                    costPerUnit={costPerUnit}
                    minutesPerUnit={minutesPerUnit}
                    gamePresets={gamePresets}
                  />
                ))}
              </div>
            )}
          </React.Fragment>
        )}
        {activeTab === 'stopwatches' && (
           <React.Fragment>
            {stopwatches.length === 0 ? (
              <div className="text-center py-20">
                <h2 className="text-2xl font-semibold text-slate-500 dark:text-slate-400">No stopwatches yet.</h2>
                <p className="text-slate-400 dark:text-slate-500 mt-2">Click "Add Stopwatch" to get started!</p>
              </div>
            ) : (
              <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-4 sm:gap-6 lg:gap-8">
                {stopwatches.map(sw => (
                  <StopwatchCard
                    key={sw.id}
                    stopwatch={sw}
                    onUpdate={updateStopwatch}
                    onDelete={deleteStopwatch}
                    onReset={handleStopwatchReset}
                    costPerUnit={costPerUnit}
                    minutesPerUnit={minutesPerUnit}
                    gamePresets={gamePresets}
                  />
                ))}
              </div>
            )}
          </React.Fragment>
        )}
        {activeTab === 'history' && (
            <HistoryView history={billingHistory} onClearHistory={handleClearHistory} />
        )}
      </main>
      <SettingsModal
        isOpen={isSettingsOpen}
        onClose={() => setIsSettingsOpen(false)}
        onSave={handleSaveSettings}
        initialCost={costPerUnit}
        initialMinutes={minutesPerUnit}
        initialPresets={gamePresets}
      />
      <BillingModal
        isOpen={isBillingModalOpen}
        onClose={() => setIsBillingModalOpen(false)}
        onConfirm={handleResetAndBill}
        totalEarnings={totalEarnings}
      />
      <ConfirmationModal
        isOpen={isClearHistoryConfirmOpen}
        onClose={() => setIsClearHistoryConfirmOpen(false)}
        onConfirm={confirmClearHistory}
        title="Clear Billing History"
        message="Are you sure you want to delete all billing history? This action cannot be undone."
        confirmButtonText="Yes, Clear It"
      />
    </div>
  );
};


// --- From index.tsx (entry point) ---
const rootElement = document.getElementById('root');
if (!rootElement) {
  throw new Error("Could not find root element to mount to");
}

const root = ReactDOM.createRoot(rootElement);
root.render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);

    </script>
  </body>
</html>
